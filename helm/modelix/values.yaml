
nameOverride: ""
fullnameOverride: ""

images:
  postgres:
    repository: postgres
    tag: 9.6
    pullPolicy: IfNotPresent
  dockerRegistry:
    repository: registry
    tag: 2.8.3
    pullPolicy: IfNotPresent
  oauthProxy:
    repository: oauth2-proxy/oauth2-proxy
    tag: "v7.8.2"
    pullPolicy: IfNotPresent
  modelServer:
    repository: modelix/model-server
    tag: "14.4.3-18d5bcd1"
    pullPolicy: IfNotPresent
  gitImport:
    repository: modelix/mps-git-import
    tag: "14.4.3-18d5bcd1"
    pullPolicy: IfNotPresent
  workspaceManager:
    repository: modelix/modelix-workspace-manager
    tag: "0.13.0-2f702fe7"
    pullPolicy: IfNotPresent
  workspaceJob:
    repository: modelix/modelix-workspace-job
    tag: "0.13.0-2f702fe7"
    pullPolicy: IfNotPresent
  proxy:
    repository: modelix/modelix-proxy
    tag: ""
    pullPolicy: IfNotPresent
  keycloak:
    repository: modelix/modelix-keycloak
    tag: ""
    pullPolicy: IfNotPresent

versions:
  modelix:
    vncBaseImage: "0.9.4"

imageTags:
  db: ""
  instancesManager: ""
  model: ""
  registry: ""
  oauth: ""
  proxy: ""
  keycloak: ""
  wsClient: ""
  wsManager: ""
  wsJob: ""

modelStorageSize: 3000Mi

# Maximal size of request body in mebibyte for ingress and proxy.
# Especially relevant for uploads in the workspace manager.
maxBodySize: 200

developmentMode: false

keycloak:
  adminPassword: "modelix"
  realm: "modelix"
  clientId: "modelix"
  clientSecret: ""
  loglevel: "warn"
  debug: false

workspaces:
  enabled: true
  uploadsStorageSize: 5000Mi
  manager:
    memory: 600Mi
  client:
    # Ports as numbers which should be exposed from MPS.
    #
    # A use case is exposing custom servers running inside MPS.
    customExposedPorts: []

ingress:
  installController: true
  hostname: "localhost"
  ingressClassName: "nginx"
  port: ""
  certSecret: ""
  tls:
    crt: ""
    key: ""

certmanager:
  # Setting this to true requires that appropriate cert-manager CRDs are
  # installed before as described here:
  # https://cert-manager.io/docs/installation/helm/#option-1-installing-crds-with-kubectl
  enabled: false

kestra:
  configuration:
    kestra:
      basic-auth:
        enabled: true
        username: admin
        password: secret
      encryption:
        secretKey: jhm3E/1WNE9EIiDsPptckrdgD4EsxaeaptnwlQyCDos=
#    micronaut:
#      server:
#        contextPath: "kestra"
  ingress:
    enabled: false
  postgresql:
    enabled: true
  dind:
    enabled: false
#  readinessProbe:
#    path: /kestra/health/readiness
#  livenessProbe:
#    path: /kestra/health/liveness
#  startupProbe:
#    path: /kestra/health

db:
  useGCloud: false
  user: "modelix"
  password: "modelix"
  db: "modelix"
  storage: 3000Mi

dockerProxy:
  prefix: ""
  secret: ""
  secret64: ""
  caCertificate: ""

internalDockerRegistry:
  # The internal docker registry does not use HTTPS.
  # Kubernetes only allows pulling images from such insecure repositories when they run on localhost.
  # Therefore, the internal docker registry is exposed through NodePort on each cluster node.
  # The node port on which it is exposed needs
  # to be known in advance because we need to specify the address for authentication.
  # The node port is configurable to allow
  # changing it in deployments where it conflicts with other statically assigned node ports.
  nodePort: 30033

serviceAccount: ""

authorization:
  enabled: true

httpProxy: ""
